## Dependencies

To build flare you need the 1.2 Development Libraries for SDL, SDL_image, SDL_mixer, and SDL_ttf.
To run flare you need the equivalent 1.2 Runtime Libraries.

http://www.libsdl.org/download-1.2.php

For easy building I recommend using cmake and make.

### Microsoft Visual C++

If you want to build flare under Microsoft Visual C++, you should get dirent.h header file
from http://softagalleria.net/dirent.php and copy it to "Microsoft Visual C++ folder"\VC\include

### Debian based systems

Installing dependencies on debian based systems (debian, Ubuntu, Kubuntu, etc):

    sudo apt-get install libsdl1.2-dev libsdl-image1.2-dev libsdl-mixer1.2-dev libsdl-ttf2.0-dev
    # for development you'll also need:
    sudo apt-get install cmake make g++ git

There is also a flare build in the Ubuntu (universe), which actually is flare-game.
http://packages.ubuntu.com/source/precise/flare

### Arch Linux

Installing dependencies on Arch Linux:

    pacman -S --asdeps sdl sdl_image sdl_mixer libogg libvorbis hicolor-icon-theme python sdl_ttf

There is also a flare-rpg-git pkgbuild at the arch user repository:
https://aur.archlinux.org/packages.php?ID=57522

### OpenSuse

Installing dependencies on openSUSE:

    sudo zypper in make cmake gcc-c++ libSDL-devel libSDL_image-devel libSDL_mixer-devel libSDL_ttf-devel

There is also a flare build at the openSUSE games repo:
http://software.opensuse.org/download.html?project=games&package=flare

### Fedora

Installing dependencies on Fedora

    yum install git make cmake gcc-c++ SDL-devel SDL_image-devel SDL_mixer-devel SDL_ttf-devel

### FreeBSD based systems

Installing dependencies on FreeBSD based systems (FreeBSD, PC-BSD, GhostBSD, etc):

    pkg_add -r cmake sdl sdl_mixer sdl_image sdl_ttf atk glib20 gdk-pixbuf2 pango git
    pkg_add -r gtk-update-icon-cache gio-fam-backend gtk-update-icon-cache pcre 

There is also a flare in the FreeBSD ports tree:
http://www.freshports.org/games/flare/


## Building from Source

There are several ways to build the game executable. For engine developers the cmake method is recommended as it has low overhead when it comes to changes in the code. However you can also build the engine with just one call to your compiler including all source files at once. This might be useful if you are
trying to run a flare based game on an obscure platform as you only need a c++ compiler and the ported SDL package.

### Building with CMake

To build the game executable, go to the main directory/folder and run the following commands:

    cmake .
    make

The executable is called ```flare``` in this repository or in the flare-game repository, but it is subject to change if you're running another game based on the engine (such as polymorphable).
If you want the game installed system-wide, as root, install with:

    make install

The game will be installed into '/usr/local' by default.  You can set different paths in the cmake step, like:

    cmake -DCMAKE_INSTALL_PREFIX:STRING="/usr" ..



### Building with g++

If you prefer building directly with C++, the command will be something like this.

Windows plus MinGW (depending on where your SDL dev headers are)

    g++ -I C:\MinGW\include\SDL src\*.cpp src\*.c -o flare.exe -lmingw32 -lSDLmain -lSDL -lSDL_image -lSDL_mixer -lSDL_ttf

Linux (depending on where your SDL includes are)

    g++ -I /usr/include/SDL src/*.cpp src/*.c -o flare -lSDL -lSDL_image -lSDL_mixer -lSDL_ttf

### Optimizing your build

Flare is intended to be able to run on a wide range of hardware.
Even on very low end hardware, such as handhelds or old computers.
To run on low end hardware smooth, we need get the best compile output possible for this device.
The following tips may help improving the the compile output with respect to speed.
However these compiler switches are not supported on some platforms, hence we do not
include it into the default compile settings.

 * Make sure the compiler optimizes for exactly your hardware. (g++, see -march, -mcpu)
 * Enable link time optimisation (g++: -flto)
   This option inlines small get and set functions accross object files reducing
   overhead in function calls.
 * More aggressive optimisation by telling the linker, it's just this program.
   (g++: -fwhole-program)
 * to be continued.
